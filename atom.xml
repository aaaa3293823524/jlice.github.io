<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木然轩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jlice.top/"/>
  <updated>2019-03-22T12:37:10.856Z</updated>
  <id>https://jlice.top/</id>
  
  <author>
    <name>文剑木然</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速幂取余算法</title>
    <link href="https://jlice.top/p/7tbs7/"/>
    <id>https://jlice.top/p/7tbs7/</id>
    <published>2019-03-21T16:07:48.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>计算a的b次方模m：</p><script type="math/tex; mode=display">a^b\ \%\ m</script><p>暴力的做法是将a乘b次，最后对m取模。不过，这样可能导致溢出，时间复杂度也很高。</p><p>现在考虑，求3的10次方，最少需要做几次乘法运算。</p><p><img src="https://img-1256819794.cos.ap-beijing.myqcloud.com/410b153a4c5a11e9a1b8dc4a3ef82d4f.jpg" alt></p><a id="more"></a><p>很显然，当计算完3×3后，可以将结果“缓存”起来，后面计算3×3就不需要计算了，直接用“缓存”的结果即可。再之后也是利用同样的思路进行计算，这样可以减少需要进行的乘法计算的次数。显然，求3的10次方，最少需要做4次乘法运算。</p><p>设 $ f(b) $ 为计算 $ a^b $ 最少需要做的乘法运算次数，显然:</p><script type="math/tex; mode=display">f(1) = 0, f(2) = 1 \\ f(2x) = f(x) + 1 \\ f(2x+1) = f(2x) + 1</script><p>其中，$ x $ 为正整数。</p><p>对于求大数余数的问题，同余模定理是很常用的：</p><script type="math/tex; mode=display">(a + b) \% c = (a \% c + b \% c) \% c</script><script type="math/tex; mode=display">(a × b) \% c = (a \% c × b \% c) \% c</script><p>由上面的思路，就可以得到快速幂取余算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这样的思路，由于乘法可以看成是多次加法，所以，也可以利用快速幂取余算法的思想计算两个大整数相乘取余。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算a的b次方模m：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;a^b\ \%\ m&lt;/script&gt;&lt;p&gt;暴力的做法是将a乘b次，最后对m取模。不过，这样可能导致溢出，时间复杂度也很高。&lt;/p&gt;
&lt;p&gt;现在考虑，求3的10次方，最少需要做几次乘法运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-1256819794.cos.ap-beijing.myqcloud.com/410b153a4c5a11e9a1b8dc4a3ef82d4f.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://jlice.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集初步</title>
    <link href="https://jlice.top/p/7ta3x/"/>
    <id>https://jlice.top/p/7ta3x/</id>
    <published>2019-03-20T03:57:31.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有若干节点，并将其中一些节点对进行连接，要判断任意两个节点是否连通（有路径到达，而不要求直接连接），连通后就不会断开连通关系，此时就可以使用并查集。并查集擅长动态维护许多具有传递性的关系，能在无向图中维护节点之间的连通性。</p><p>要判断两个节点是否连通，可以把连通的节点加入到各自的集合里，也就是，同一个集合里的节点都是连通的，不同集合里的节点是不连通的。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/33a675d24ac811e98294509a4c21c90b.png" alt></p><a id="more"></a><p>如图，节点a、b、c、d属于同一个集合，它们之间是连通的；节点x、y、z属于同一个集合，它们之间也是连通的。但是，不同集合里的节点，如b和x，是不连通的。</p><p>可以发现，每个集合构成了树形的结构，同一个集合里的节点，它们的根节点是相同的。要判断两个节点是否连通，只需要判断它们的根节点是否一致即可。</p><p>并查集的API定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找节点的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 连接节点p和q</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 判断两个节点是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>并查集的存储结构可以使用数组或链表，一般采用数组作为实现的方式。<strong>数组记录元素的父节点</strong>。例如，A[i] = j，表示节点i的父节点是节点j。</p><p>初始时，每个节点各自作为一个集合，也就是节点的父节点是自身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UF(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查找节点的根节点时，如果节点的父节点是自身，那么该节点就是根节点。否则，顺着父节点不断向上找，直至根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[x] == x ? x : find(parent[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接两个节点时，实际上就是把两个节点的所在的集合合并成一个。首先需要找到两个节点的根节点，把其中一个根节点的父节点修改为另一个根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    parent[find(x)] = find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>对于 find 的过程，可以修改节点的父节点来加速下次查找，这个优化称为“路径压缩”。</p><p>例如，在查找根节点的过程中，修改沿途节点的父节点为根节点：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/70eb251a4ae511e98f3b509a4c21c90b.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent[x] == x ? x : parent[x] = find(parent[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (parent[root] != root) &#123;</span><br><span class="line">        root = parent[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;</span><br><span class="line">        tmp = parent[x];</span><br><span class="line">        parent[x] = root;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其它的路径压缩方式。例如，在查找根节点的过程中，若节点不是根节点，就将节点的父节点修改为爷节点（父节点的父节点）：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/2e274fda4ae711e9bc82509a4c21c90b.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h2><p>对于 join 的过程，如果不加任何策略合并，可能会形成很长的路径，应该尽量选择深度更小的集合的根节点进行父节点的修改。</p><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>集合的秩，也就是集合所对应的树的深度。</p><p>如果两个集合的秩不相等，就把秩小的集合的根节点的父节点修改为秩大的集合的根节点。如果两个集合的秩相等，那么，将其中一个集合的根节点的父节点修改为另一个集合的根节点，同时，将未修改父节点的根节点的集合的秩+1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UF(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.push_back(i);</span><br><span class="line">            rank.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[xRoot] &gt; rank[yRoot]) &#123;</span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">                <span class="keyword">if</span> (rank[xRoot] == rank[yRoot]) &#123;</span><br><span class="line">                    rank[yRoot]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>也可以在根节点存储秩的信息，思路参考下面的“按size合并”</p><h3 id="按size合并"><a href="#按size合并" class="headerlink" title="按size合并"></a>按size合并</h3><p>为了记录集合的size，也就是集合包含节点的个数，可以将根节点的父节点的值修改为“-1*集合包含节点的个数”，同时，根节点的判断方式修改为父节点的值小于0。合并时，将节点数少的集合并入节点数多的集合，也就是修改节点数少的集合的根节点的父节点为节点数多的集合的根节点。注意，在修改父节点前要更新节点数多的集合的节点数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UF(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.push_back(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[x] &lt; <span class="number">0</span> ? x : parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = find(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = find(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot != yRoot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[xRoot] &lt; parent[yRoot]) &#123;</span><br><span class="line">                parent[xRoot] += parent[yRoot];</span><br><span class="line">                parent[yRoot] = xRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[yRoot] += parent[xRoot];</span><br><span class="line">                parent[xRoot] = yRoot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>不过，按size合并的策略并不总能选择深度更小的集合的根节点进行父节点的修改，例如本文第一个图的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;有若干节点，并将其中一些节点对进行连接，要判断任意两个节点是否连通（有路径到达，而不要求直接连接），连通后就不会断开连通关系，此时就可以使用并查集。并查集擅长动态维护许多具有传递性的关系，能在无向图中维护节点之间的连通性。&lt;/p&gt;
&lt;p&gt;要判断两个节点是否连通，可以把连通的节点加入到各自的集合里，也就是，同一个集合里的节点都是连通的，不同集合里的节点是不连通的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1256819794.cos.ap-shanghai.myqcloud.com/33a675d24ac811e98294509a4c21c90b.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://jlice.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>解决Deepin桌面下Office图标显示为压缩包</title>
    <link href="https://jlice.top/p/7t7af/"/>
    <id>https://jlice.top/p/7t7af/</id>
    <published>2019-03-17T15:03:25.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>在使用ArchLinux系的系统（比如我用的Manjaro），使用Deepin桌面时，Office图标会显示为压缩包：</p><p><img src="https://img-1256819794.cos.ap-beijing.myqcloud.com/d772cda848c511e9ba48dc4a3ef82d4f.jpg" alt></p><p>虽然说，docx、xlsx、pptx格式其实也就是zip包，但图标错乱还是会让强迫症的我感觉很难受。不过，在Xfce4桌面环境下是没有这个问题的，Office图标正确显示为Office图标，但Deepin下就有这种问题，有点奇怪。</p><a id="more"></a><p>究其原因，和WPS有关。在参考了帖子：</p><p><a href="https://forum.manjaro.org/t/xlsx-and-docx-files-are-opened-as-zip-file/25814" target="_blank" rel="noopener">.xlsx and .docx files are opened as zip file - Technical Issues and Assistance / Applications - Manjaro Linux Forum</a></p><p><a href="https://forum.manjaro.org/t/deepin-docx-shown-as-zip-icon/43129" target="_blank" rel="noopener">(Deepin) .docx shown as .zip (icon) - Support for Community Editions - Manjaro Linux Forum</a></p><p><a href="https://forum.manjaro.org/t/after-installing-wps-office-office-icons-change/65712/4" target="_blank" rel="noopener">After Installing WPS-Office Office Icons Change - Technical Issues and Assistance / Applications - Manjaro Linux Forum</a></p><p>然后，终于找到了解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/share/mime/packages/wps-office-*.xml</span><br><span class="line">$ sudo update-mime-database /usr/share/mime</span><br></pre></td></tr></table></figure><p>弄完之后，Office图标就恢复正常了。</p><p><img src="https://img-1256819794.cos.ap-beijing.myqcloud.com/1e4a7a5e48c711e9ab9ddc4a3ef82d4f.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用ArchLinux系的系统（比如我用的Manjaro），使用Deepin桌面时，Office图标会显示为压缩包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-1256819794.cos.ap-beijing.myqcloud.com/d772cda848c511e9ba48dc4a3ef82d4f.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;虽然说，docx、xlsx、pptx格式其实也就是zip包，但图标错乱还是会让强迫症的我感觉很难受。不过，在Xfce4桌面环境下是没有这个问题的，Office图标正确显示为Office图标，但Deepin下就有这种问题，有点奇怪。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《实战Java高并发程序设计》读书笔记</title>
    <link href="https://jlice.top/p/7t3gc/"/>
    <id>https://jlice.top/p/7t3gc/</id>
    <published>2019-03-14T04:12:21.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>这两天快速看了下《实战Java高并发程序设计》这本书，对Java高并发程序有一个初步的认识。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/c3864a28460f11e9b111509a4c21c90b.jpg" alt></p><p>这本书是在iPad上用MarginNotes 3看的，只是做了些笔记，还没进行代码实践，后续还需要细化。</p><a id="more"></a><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/573fbc52461211e9a50a509a4c21c90b.jpg" alt></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的，而并行是真正意义上的“同时执行”。</p><p><strong>临界区</strong>用来表示一种公共资源或者说共享数据，可以被多个线程使用。但是每一次， 只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</p><p><strong>原子性</strong>是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作旦开始，就不会被其他线程干扰。</p><p>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</p><p>关键字 <strong>volatile</strong> 并不能代替锁，它也无法保证一些复合操作的原子性。关键字 volatile 也能保证数据的可见性和有序性。</p><p>当一个Java应用内只有守护线程时，Java虚拟机就会自然退出。</p><p>关键字 <strong>synchronized</strong> 的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性。</p><h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><p><strong>重入锁</strong> 使用 java.util.concurrent.locks.ReentrantLock 类来实现</p><p>重入锁有着显示的操作过程。开发人员必须手动指定何时加锁，何时释放锁。</p><p>一个线程连续两次获得同一把锁是允许的</p><p>如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数。</p><p>如果释放锁的次数多了，那么会得到一个 java.lang.IllegaMonitorStateException 异常</p><p>如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p><p>lockInterruptibly()是一个可以对中断进行响应的锁申请动作，即在等待锁的过程中，可以响应中断。</p><p>使用 tryLock() 方法进行一次限时的等待。</p><p>重入锁允许对其公平性进行设置，公平锁的实现成本比较高，性能却非常低下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><p>利用 <strong>Condition</strong> 对象， 可以让线程在合适的时间等待，或者在某一个特定的时刻得到通知，继续执行。</p><p><strong>信号量</strong>(Semaphore)：信号量可以指定多个线程，同时访问某一个资源</p><p>ReadwriteLock是<strong>读写分离锁</strong>。可以有效地帮助减少锁竞争提升系统性能。</p><p>倒计数器: CountdownLatch</p><p>循环栅栏: <strong>CyclicBarrier</strong></p><p>CyclicBarrier 可以接收一个参数作为 barrierAction 就是当计数器一次计数完成后，系统会执行的动作。</p><p>LockSupport是一个非常方便实用的线程阻塞工具，它可以在线程内任意位置让线程阻塞。</p><p>更为一般化的<strong>限流算法</strong>有两种:漏桶算法和令牌桶算法。</p><p>在使用线程池后，创建线程变成了从线程池获得空闲线程，关闭线程变成了向线程池归还线程</p><p><strong>Executor框架</strong></p><ul><li>newFixedThreadPool() 方法:该方法返回一个固定线程数量的线程池。</li><li>newSingleThreadExecutor() 方法:该方法返回一个只有一个线程的线程池。</li><li>newCachedThreadPool() 方法:该方法返回一个可根据实际情况调整线程数量的线程池</li><li>newSingleThreadScheduledExecutor() 方法: 扩展了在给定时间执行某任务的功能</li><li>newScheduledThreadPool() 方法: 可以指定线程数量。</li></ul><p>核心线程池的内部实现：都只是 Threadpoolexecutor 类的封装</p><p>拒绝策略</p><p>自定义线程创建: ThreadFactory</p><p>ThreadPoolExecutor 是一个可以扩展的线程池。它提供了beforeExecute()、afterExecute()、terminaerd() 三个接口用来对线程池进行控制。</p><p>除JDK内置的线程池以外，Guava 对线程池也进行了一定的扩展</p><p>DirectExecutor线程池总是将任务在当前线程中直接执行</p><p>将普通线程池转为Daemon线程池的方法 MoreExecutors.getExitingExecutorService()</p><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p><strong>ConcurrentHashMap</strong>：这是一个高效的并发 Hashmap</p><p><strong>CopyOnWriteArrayList</strong>: 在读多写少的场合，这个List的性能非常好，远远优于 Vector。读取是完全不用加锁的， 写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。</p><p><strong>ConcurrentLinkedQueue</strong>：高效的并发队列</p><p><strong>BlockingQueue</strong> 表示阻塞队列，非常适合作为数据共享的通道。BlockingQueue 让服务线程在队列为空时进行等待，当有新的消息进入队列后，自动将线程唤醒</p><p><strong>ConcurrentSkipListMap</strong>：跳表的实现。</p><p><strong>JMH</strong> (Java Microbenchmark Harness) 专门用于性能测试的框架，其精度可以到达毫秒级。  </p><ul><li>Mode表示JMH的测量方式和角度</li><li>迭代是JMH的一次测量单位</li><li>通过 State可以指定一个对象的作用范围。JMH中的 State可以理解为变量或者数据模型的作用域，通常包括整个 Benchmark级别和 Thread线程级别。</li></ul><h2 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h2><p>减少锁持有时间</p><p>减小锁粒度。所谓减小锁粒度，就是指缩小锁定对象的范围，从而降低锁冲突的可能性，进而提高系统的并发能力</p><p>用<strong>读写分离锁</strong>来替换独占锁。在读多写少的场合使用读写锁可以有效提升系统的并发能力</p><p><strong>锁分离</strong></p><p><strong>锁粗化</strong>  虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数，这个操作叫作锁的粗化。</p><p><strong>锁偏向</strong><br>锁偏向的核心思想是:如果一个线程获得了锁， 那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。<br>使用Java虚拟机参数<code>-XX:+UseBiasedLocking</code>可以开启偏向锁。</p><p><strong>轻量级锁</strong><br>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p><p><strong>自旋锁</strong><br>让当前线程做几个空循环(这也是自旋的含义)， 如果还不能获得锁，才会真的将线程在操作系统层面挂起</p><p><strong>锁消除</strong><br>Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竟争的锁。</p><p><strong>逃逸分析</strong><br>观察某一个变量是否会逃出某一个作用域</p><p><strong>Threadlocal</strong></p><p>ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量。 它采用采用空间来换取时间的方式，解决多线程中相同变量的访问冲突问题。<br>为每一个线程分配不同的对象，需要在应用层面保证 ThreadLocal 只起到了简单的容器作用。ThreadLocalMap 是定义在 Thread 内部的成员，ThreadLocalMap的实现使用了弱引用。</p><p><strong>无锁</strong>的策略使用一种叫作比较交换(CAS， Compare And Swap)的技术来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。</p><p><strong>CAS算法</strong>的过程是:它包含三个参数CAS(VE，N)，其中V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果值和E值不同， 说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p><p>JDK并发包中有一个<strong>atomic</strong>包，里面实现了一些直接使用CAS操作的线程安全的类型。</p><ul><li>Atomicinteger 是可变的，并且是线程安全的。Unsafe类就是封装了一些类似指针的操作</li><li>Atomicreference 可以保证在修改对象引用时的线程安全性</li><li>Atomicstampedreference 内部不仅维护了对象值，还维护了一个时间</li><li>Atomiclntegerarray， Atomiclong Array 和 Atomicreferencearray</li><li>让普通变量也享受原子操作: Atomiclntegerfieldupdater</li></ul><p><strong>死锁</strong><br>哲学家就餐问题</p><h2 id="并行模式与算法"><a href="#并行模式与算法" class="headerlink" title="并行模式与算法"></a>并行模式与算法</h2><p><strong>【单例模式】</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StaticSingleton is create"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不变模式</strong></p><p>对属性的final定义确保所有数据只能在对象被构造时赋值1次。之后，就永远不发生改变。</p><p>对class的final确保了类不会有子类</p><p><strong>【生产者-消费者模式】</strong></p><p>生产者-消费者模式中的内存缓冲区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者间的性能差。</p><p>BlockigQueue 充当了共享内存缓冲区，用于维护任务或数据队列</p><p>Disruptor 框架使用无锁的方式实现了一个环形队列，非常适合实现生产者-消费者模式</p><p>消费者监控冲区中的信息策略由 WaitStrategy 接口进行封装，</p><p>当两个变量存放在一个缓存行时，在多线程访问中，可能会影响彼此的性能。</p><p><strong>Future模式</strong></p><p>Future 模式的核心思想是异步调用</p><p><strong>并行流水线</strong></p><p>执行过程中有数据相关性的运算都是无法完美并行化的</p><p>并行搜索</p><p><strong>并行排序</strong></p><p>奇偶交换排序</p><p>希尔排序</p><p><strong>矩阵乘法</strong></p><p>将矩阵A进行水平分割，得到子矩阵A1和A2，矩阵B进行垂直分割，得到子矩阵B1和B2。再将结果进行拼接就能得到原始矩阵A和B的乘积。</p><p><strong>网络NIO</strong></p><p><strong>AIO</strong></p><h2 id="Java新特性"><a href="#Java新特性" class="headerlink" title="Java新特性"></a>Java新特性</h2><p>在Java8中，使用 default关键字可以在接口内定义实例方法</p><p>函数式接口就是只定义了单一抽象方法的接口</p><p>方法引用使用 :: 定义， :: 的前半部分表示类名或者实例名，后半部分表示方法名称。如果是构造函数，则使用new表示。</p><p>parallel() 方法得到一个并行流</p><p>集合对象并行化可以使用 parallelStream() 函数</p><p>Arrays.parallelSort() 方法直接使用并行排序</p><p>新版本的 <strong>ConcurrentHashMap</strong> 增加了一些foreach操作、reduce操作、computeIfAbsent()、search操作</p><p>newKeySet() 方法返回一个线程安全的Set</p><p>在反应式编程中，核心的两个组件是Publisher和Subscriber。Publisher将数据发布到流中， Subsciber则负责处理这些数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天快速看了下《实战Java高并发程序设计》这本书，对Java高并发程序有一个初步的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1256819794.cos.ap-shanghai.myqcloud.com/c3864a28460f11e9b111509a4c21c90b.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这本书是在iPad上用MarginNotes 3看的，只是做了些笔记，还没进行代码实践，后续还需要细化。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>拼多多2020实习笔试题题解</title>
    <link href="https://jlice.top/p/7szz3/"/>
    <id>https://jlice.top/p/7szz3/</id>
    <published>2019-03-11T01:03:03.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>题解是交卷后做的，不保证AC。</p><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p><strong>题目描述</strong></p><p>给出长虔都为n的两个整数数组a[n]和b[n]，特殊运算 S = a[0]*b[0] + … + a[n-1]*b[n-1]，你可以改变a数组的顺序使得运算S得到的值最小，给出最终的最小值。<br>数组长度n大于50，对于每个元素X，0&lt;=X&lt;=100。</p><a id="more"></a><p><strong>输入描述</strong></p><p>输入一共三行。<br>第一行为n，表示两个数组的长度。<br>第二行包括n个数字，用空格隔开，是a数组的值。<br>第三行包括n个数字，用空格隔幵，是b数组的值。</p><p><strong>输出描述</strong></p><p>输出一行，包含一个数字，表示最小的S值。</p><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 3</span><br><span class="line">10 30 20</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>水题。先对数组a、b排序，一个升序遍历一个降序遍历。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">a = sorted(list(map(int, input().split())))</span><br><span class="line">b = sorted(list(map(int, input().split())), reverse=<span class="literal">True</span>)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    res += a[i] * b[i]</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><strong>题目描述</strong></p><p>小明给儿子小小明买了一套英文字母卡片（总共包合52张，区分大小写）,小小明把卡片丢在地上玩耍，并从中取出若干张排成一排，形成了一个卡片序列。<br>此时．小明需要将卡片序列中的重复字母剔除（同一个字母的大小写只保留一个）。<br>请问，所有可能的结果中，字母序最小（不区分大小写）的序列的第一张卡片上是哪个字母？ </p><p><strong>输入描述</strong></p><p>一行输入，包合一个非空字符串，表示卡片序列，长度为 N（1＜=N＜=52）。 </p><p><strong>输出描述</strong></p><p>一行输出，包合一个字母（如果结果是大写字母，则需要转成小写）。  </p><p><strong>示例1</strong> </p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xaBXY</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure><p>说明</p><p>剔除完后的结果为abxy</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这道题题意比较绕。大意就是，52个字母中的若干个组成的一个序列，对于每对重复字母（不区分大小写），都剔除其中一个，由于剔除的位置不同，处理后的序列有多种情况，从中找到字母序最小的，返回其首字母。</p><p>例如，xaBXY，其中x重复出现，剔除其中一个x，有两种情况：aBXY、xaBY，前者的字母序最小，所以返回其首字母a。<br>又如，bBa，有两种情况：Ba、ba，两者不区分大小写是一样的，首字母是b。<br>又如，cDadC，字母序最小的序列是adC，返回a。</p><p>理清楚题意后，解决起来就比较简单。考虑哪些字母可能成为序列的首字母。从左往右扫描，如果遇到只出现一次的字母，由于该字母不会被剔除，所以其后的字母将不会成为首字母，将该字母加入待选首字母并结束扫描；如果遇到出现两次的字母，若第一次遇到该字母，则将该字母加入待选并继续扫描，但若第二次遇到该字母，就需要停止扫描了，因为如果剔除前一个该字母，则当前位置的该字母将会被保留，所以其后的字母将不会成为首字母。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">s = input().lower()</span><br><span class="line">cnt = Counter(list(s))</span><br><span class="line">rec = set()</span><br><span class="line">heads = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> cnt[c] == <span class="number">1</span>:</span><br><span class="line">        heads.append(c)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> rec:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heads.append(c)</span><br><span class="line">            rec.add(c)</span><br><span class="line">print(min(heads))</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p><strong>题目描述</strong></p><p>小镇沿街分布（可以理解为都在数轴上），有n家银行（位置以数轴的坐标表示，金额表示可以被抢走的金额），两个绑匪试图分别抢劫一个银行，为了让警方多奔波他们商定选择的两个银行距离不小于d，请问符合约定的情况下他们能抢到的总金额最大是多少？ </p><p><strong>输入描述</strong></p><p>输入包括 n+1 行。<br>第一行包含两个数字n和d（1&lt;=n&lt;=200000，1&lt;=d&lt;=100000000)，n表示银行的数量，d表示约定的距离。<br>下面n行，每一行包括两个数字a, b（1&lt;=a,b&lt;=100000000），分别表示坐标和金额，空格分隔。 </p><p><strong>输出描述</strong></p><p>输出一个数字，表示可以获得的最大金额。 </p><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 1</span><br><span class="line">3 5</span><br><span class="line">4 8</span><br><span class="line">6 4</span><br><span class="line">10 3</span><br><span class="line">11 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先，需要对银行按位置排序。对于每家银行，找到其右侧符合距离限制的金额最大值。</p><p><img src="https://img-1256819794.cos.ap-beijing.myqcloud.com/666f6d1e43a211e99540dc4a3ef82d4f.jpg" alt></p><p>由于每次都需要某位置及其右侧的金额最大值，不妨先计算出来，存为后缀max数组。然后，对于每家银行，找到其右侧符合距离限制且最近的银行，取其后缀max数组的值，即右侧银行可获得的最大金额，并更新可获得的最大金额。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; banks(n, make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; banks[i].first &gt;&gt; banks[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(banks.begin(), banks.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rmax(n, banks.back().second);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rmax[i] = max(banks[i].second, rmax[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (banks[j].first - banks[i].first &gt;= d) &#123;</span><br><span class="line">                res = max(res, banks[i].second + rmax[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p><strong>题目描述</strong></p><p>一个合法的圆括号表达式满足一下条件：<br>1．””空字符串被认为是合法的<br>2．如果字符串”X”与”Y”是合法的，则”XY”也被认为是合法的<br>3．如果字符串”X”是合法的，则”(X)”也是合法的<br>例子：””, “()”, “()()”, “(())”这些都是合法的<br>现给出两个不保证合法的由圆括号组成的字符串，你需要交错这两个圆括号序列（在组成的新字符串中，每个初始字符串都保持原来的顺序）得到一个新的合法的圆括号表达式（不同的交错方式可能会得到相同的表达式，这种情况分开计数），求共有多少结果合法的交错方式（无法得到合法的圆括号表达式则输出0），输出结果模 10^9+7 的值(^符号是乘方的意思） </p><p><strong>输入描述</strong></p><p>输入包括两行，分别是两个只有”(和”)”组成的字符串，长度小于2500</p><p><strong>输出描述</strong></p><p>输出为一个数字，表示合法的交错方式数量模上10^9+7的结果</p><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(()</span><br><span class="line">())</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>好吧，不会。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题解是交卷后做的，不保证AC。&lt;/p&gt;
&lt;h2 id=&quot;题目1&quot;&gt;&lt;a href=&quot;#题目1&quot; class=&quot;headerlink&quot; title=&quot;题目1&quot;&gt;&lt;/a&gt;题目1&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出长虔都为n的两个整数数组a[n]和b[n]，特殊运算 S = a[0]*b[0] + … + a[n-1]*b[n-1]，你可以改变a数组的顺序使得运算S得到的值最小，给出最终的最小值。&lt;br&gt;数组长度n大于50，对于每个元素X，0&amp;lt;=X&amp;lt;=100。&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://jlice.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>N-sum问题通解</title>
    <link href="https://jlice.top/p/7qvfi/"/>
    <id>https://jlice.top/p/7qvfi/</id>
    <published>2019-01-01T03:42:48.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>N-sum 问题还是比较典型的，这里进行一下小结。</p><p>首先描述一下 N-sum 问题：有一个数组 nums，要求从数组中选择 n 个数，使得这些数的和恰好为 target ，输出所有不重复的可行组合。</p><p>如果采用暴力解法，显然时间复杂度为 $O(N^n)$，这一般是不可取的。</p><p>下面是 N-sum 问题的LeeCode链接：</p><a id="more"></a><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">1. Two Sum</a></p><p><a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15. 3Sum</a></p><p><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">18. 4Sum</a></p><h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two-Sum"></a>Two-Sum</h2><p>先来解决Two-Sum问题，这是N-sum问题的基础。如果我们能把Two-Sum的时间复杂度降为 $O(N)$ ，然后就能把N-sum的时间复杂度降为 $O(N^{n-1})$ 了。</p><p>如果采用暴力解法，每次选择一个数时，都要遍历数组来选择另一个数，并判断和是否为 target，这样显然是低效的。当我们选择一个数 x 时，我们希望数组里有一个数为 target - x。为了快速判断数组里是否有某个数，可以用 HashSet。但是，这样存在问题，因为数组里可能有重复的数，当 x 等于 target - x 时，这种做法就错了。因此，正确的做法应该是用 HashMap，用来存储各个数还有多少可用。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>另一种解法是使用“双指针”，这种解法要求 nums 是有序的。例如，nums 为 [1, 2, 4, 7, 13, 16]，target 为 15。初始时，指针p、q位于两端：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/a5ae722e0d7c11e9ae48509a4c21c90b.png" alt></p><p>如果p、q所指向的值之和大于 target，那么q往左移，这是因为q左侧的值比q所指的值小，所以q往左移能使得之和变小；<br>如果之和小于 target，那么p往右移，这是因为p右侧的值比p所指的值大，所以p往右移能使得之和变大；<br>如果之和等于 target，那么p往右移且q往左移（有点像夹挤），这个稍微有点难理解，这也是“双指针”法的思想精髓。首先，如果p往左移或q往右移，其实就回到了之前的状态；其次，如果只是p往右移，显然之和会大于 target，如果只是q往左移，显然之和会小于 target；于是乎，p往右移且q往左移。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/3f87a4d80d9711e9b32b509a4c21c90b.png" alt></p><p>然后就是考虑如何判断可行组合是否重复。由于数组是有序的，可行组合的加入也是有序的，因此，只需判断当前可行组合与最后一个已加入的可行组合是否重复即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> st, <span class="keyword">int</span> ed) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">while</span> (st &lt; ed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[st] + nums[ed] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || res.back()[<span class="number">0</span>] != nums[st]) &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[st], nums[ed]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ++st;</span><br><span class="line">            --ed;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[st] + nums[ed] &gt; target) &#123;</span><br><span class="line">            --ed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++st;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-Sum"><a href="#N-Sum" class="headerlink" title="N-Sum"></a>N-Sum</h2><h3 id="问题转化"><a href="#问题转化" class="headerlink" title="问题转化"></a>问题转化</h3><p>对于 N-sum 问题，外面几层其实就是暴力遍历，只有最后两个数转为 Two-Sum 问题，使用双指针法求解。这种做法，其实就相当于把时间复杂度降了一阶。</p><p>例如，对于 3-Sum 问题，先从有序数组 nums 中取一个数（遍历），然后从该数右侧的数里再取两个数（Two-Sum）；对于 4-Sum 问题，先从有序数组 nums 中取两个数（遍历），然后从这两个数的右侧里再取两个数（Two-Sum）。可见，4-Sum 只是比 3-Sum 多了一层循环。为了控制循环层数，可以使用递归。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> st, <span class="keyword">int</span> ed, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> twoSum(nums, target, st, ed);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=st; i&lt;=ed; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || res.back()[<span class="number">0</span>] != num) &#123;</span><br><span class="line">                <span class="keyword">auto</span> ret = nSum(nums, target-num, i+<span class="number">1</span>, nums.size()<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> r : ret) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                    tmp.push_back(num);</span><br><span class="line">                    tmp.insert(tmp.end(), r.begin(), r.end());</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“双指针”的想法还是比较巧妙的，如果没见过，还真的不容易想出来。所以，练习是有必要的，也需要进行归纳总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N-sum 问题还是比较典型的，这里进行一下小结。&lt;/p&gt;
&lt;p&gt;首先描述一下 N-sum 问题：有一个数组 nums，要求从数组中选择 n 个数，使得这些数的和恰好为 target ，输出所有不重复的可行组合。&lt;/p&gt;
&lt;p&gt;如果采用暴力解法，显然时间复杂度为 $O(N^n)$，这一般是不可取的。&lt;/p&gt;
&lt;p&gt;下面是 N-sum 问题的LeeCode链接：&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://jlice.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>求单链表交点</title>
    <link href="https://jlice.top/p/7qhfm/"/>
    <id>https://jlice.top/p/7qhfm/</id>
    <published>2018-12-19T13:22:33.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>今天面试时，面试官问了这样一个问题：两个单链表相交，怎么求交点。所谓相交，就是两个节点的next指针相同。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/f51d0ee6039211e98b95509a4c21c90b.png" alt></p><a id="more"></a><h2 id="简单解法"><a href="#简单解法" class="headerlink" title="简单解法"></a>简单解法</h2><p>一个简单的思路是：分别遍历这两个链表，并将这两个链表的节点分别保存到两个列表里，然后同步逆序遍历这两个列表，当出现不相同的元素时，则下一个元素就是这两个链表的交点。</p><p>例如，对于上图的两个单链表，遍历上面的单链表得到列表：A, B, C, D, E, F, G；遍历下面的单链表得到列表：H, I, E, F, G。因为单链表相交之后就汇合了，汇合之后的节点就是一样的，而汇合之前的节点不一样，所以同步逆序遍历这两个列表：G-G, F-F, E-E, D-I……于是，E节点就是交点。</p><p>这种做法时间复杂度为<script type="math/tex">O(n)</script>，但空间复杂度为<script type="math/tex">O(n)</script>，有没有空间复杂度更低的解法呢？</p><p>如果使用HashMap存储，先遍历上面的单链表，并把节点存储到HashMap里，然后遍历下面的单链表，每次都看当前节点是否已经存在于HashMap中，如果存在，则该节点就是交点。采用这种做法，不必把两个单链表都遍历完，不过依然没有降低空间复杂度。</p><p>另一种思路是暴力法，也就是遍历这两个链表，判断第一个链表的每个节点是否在第二个链表中，这种做法的时间复杂度为<script type="math/tex">O(n^2)</script>。</p><h2 id="优雅解法"><a href="#优雅解法" class="headerlink" title="优雅解法"></a>优雅解法</h2><p>这个问题比较麻烦的地方在于，这两个单链表相交之前的部分的长度可能不一致。假如这两个单链表长度一致，那么指针p、q只要同步移动，然后首次相遇的地方就是交点了。</p><p>例如，对于图中的两个单链表，假如上面的单链表没有A, B节点，指针p初始指向C节点，那么，指针p、q只要同步移动两次，就会在节点E相遇，E节点就是交点。那么，我们要怎么样让指针p指向C节点后，指针p、q才同步移动呢？</p><p>其实很简单，先遍历一下这两个单链表，得到它们的长度，然后让长的单链表的指针先走长度之差步，就可以了！对于图中的两个单链表，上面的单链表长度为7，下面的单链表长度为5，两个单链表的长度之差为2，且上面的单链表更长，那么就让指针p先走2步（这样就到了C节点），然后指针p、q同步移动即可。</p><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><h3 id="如何判断两个单链表是否相交"><a href="#如何判断两个单链表是否相交" class="headerlink" title="如何判断两个单链表是否相交"></a>如何判断两个单链表是否相交</h3><p>这个问题比较简单。显然，如果两个单链表相交，则必然是“Y”形的，而不是“X”形的。只需要判断两个单链表中是否存在相同的元素即可。</p><p>如果这两个单链表相交，则尾节点必然相同，因此，直接遍历到尾节点，然后判断尾节点是否相同即可。还可以把节点存到哈希表，在遍历第二个单链表时，判断节点是否在哈希表中已存在，若已存在则相交。</p><h3 id="如何判断单链表里是否有环"><a href="#如何判断单链表里是否有环" class="headerlink" title="如何判断单链表里是否有环"></a>如何判断单链表里是否有环</h3><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/f573e938039811e9b2c2509a4c21c90b.png" alt></p><p>这个可以采用<strong>快慢指针</strong>的技巧。初始时，指针p、q都位于初始节点，然后每次指针p移动一个节点，指针q移动两个节点，则指针p、q必然在环内相遇。</p><p>为什么指针p、q必然在环内相遇呢？这是因为在环内，可以看成是指针q“追赶”指针p，每次“追赶”1一个节点（也就是相对距离-1），所以必然能相遇。而且，指针p、q相遇时，指针p在环内走过的距离不会超过环的长度。</p><p>LeetCode: <a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">141. Linked List Cycle</a></p><h3 id="如何求单链表的环的长度"><a href="#如何求单链表的环的长度" class="headerlink" title="如何求单链表的环的长度"></a>如何求单链表的环的长度</h3><p>很简单：根据上一个问题可以知道一个处于环内的节点，固定指针q，然后继续移动指针p（指针p每次移动一个节点），当指针p、q再次相遇时，指针p继续移动的次数就是环的长度。</p><h3 id="如何求单链表中第一个在环里的节点"><a href="#如何求单链表中第一个在环里的节点" class="headerlink" title="如何求单链表中第一个在环里的节点"></a>如何求单链表中第一个在环里的节点</h3><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/d42139c003fb11e9a7f6509a4c21c90b.png" alt></p><p>假设单链表起点到第一个在环里的节点的距离为<script type="math/tex">n</script>，快慢指针p、q在环内相遇，第一个在环里的节点到相遇点的距离为<script type="math/tex">f</script>，环的长度为<script type="math/tex">L</script>。</p><p>那么，显然，指针p、q相遇时，指针p走过的距离为<script type="math/tex">n+f</script>，指针q走过的距离为<script type="math/tex">n+f+xL</script>（之所以是<script type="math/tex">xL</script>是因为，假如<script type="math/tex">n</script>较大而<script type="math/tex">L</script>较小，那么指针q可能在环内转了好几圈才和指针p相遇）。显然有：</p><script type="math/tex; mode=display">2(n+f) = n+f+xL</script><p>故 <script type="math/tex">n = xL-f, x>0</script>，或者写为：</p><script type="math/tex; mode=display">n = L - f + xL \quad x\geq0</script><p>而指针p、q的相遇点到第一个在环里的节点的距离为<script type="math/tex">L-f</script>。指针p从单链表的起点开始移动，每次移动1个节点，指针q从相遇点开始移动，每次也移动1个节点，那么，指针p、q就会在第一个在环里的节点处相遇。</p><p>LeetCode: <a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142. Linked List Cycle II</a></p><h2 id="特殊解法"><a href="#特殊解法" class="headerlink" title="特殊解法"></a>特殊解法</h2><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/e59a7a1403ff11e9b32a509a4c21c90b.png" alt></p><p>对于本文最开始的问题，还有一种比较特殊的解法。先遍历其中一个链表，遍历到尾节点时，将尾节点的next指针指向另一个链表的起点，然后，问题就转化为求单链表中第一个在环里的节点了。</p><p>后记：</p><p>在LeetCode上刷到了原题：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists</a>，还是要多刷题啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;今天面试时，面试官问了这样一个问题：两个单链表相交，怎么求交点。所谓相交，就是两个节点的next指针相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1256819794.cos.ap-shanghai.myqcloud.com/f51d0ee6039211e98b95509a4c21c90b.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="刷题" scheme="https://jlice.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>memset的一个坑</title>
    <link href="https://jlice.top/p/7qghk/"/>
    <id>https://jlice.top/p/7qghk/</id>
    <published>2018-12-18T16:56:30.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>为数组赋初值是很常见的操作，如果不赋初值，默认就是随机值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想将a中的元素全部赋为0，第2行可以写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这是C++ 11的写法，在此之前应写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果想把第0个元素赋为1，其余赋为0呢，那么可以写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意这里并不是把数组的元素全部设为1。</p><p>如果把数组定义为全局变量，那么会在堆中创建，会初始化为默认值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时数组a的元素会全部初始化为0。</p><p>如果想把数组重置为全0，那么可以用<code>memset</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br></pre></td></tr></table></figure><p>那么，怎么把数组里所有元素全部赋初值1呢？</p><p>一个很容易犯的错误写法就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="keyword">sizeof</span> a);</span><br></pre></td></tr></table></figure><p>若如此做，a中的元素都是16843009。为什么会这样呢？</p><p>这是<code>memset</code>的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>其实<code>memset</code>是给字节数组赋初值的！<code>memset</code>会对s <strong>逐字节填充</strong> 值c。由于int有4字节，所以上面那个错误写法导致每个元素被写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01010101</span><br></pre></td></tr></table></figure><p>转为十进制也就是16843009。</p><p>所以，还是用循环吧……这时，有点怀念Python的给list赋初值的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>] * <span class="number">5</span></span><br></pre></td></tr></table></figure><p>不过，别用list赋初值，因为是浅拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[]] * <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为数组赋初值是很常见的操作，如果不赋初值，默认就是随机值：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想将a中的元素全部赋为0，第2行可以写为：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://jlice.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>详解Minimax算法与α-β剪枝</title>
    <link href="https://jlice.top/p/7q6ye/"/>
    <id>https://jlice.top/p/7q6ye/</id>
    <published>2018-12-10T03:02:36.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>在局面确定的双人对弈里，常采用博弈树搜索。我方追求更大的赢面，而对方会设法降低我方的赢面。由于局面确定，因此可以对赢面进行评估。我方往较大赢面的方向走，同时考虑对方的走法。由于对方的走法不确定，就假设对方会选择最大程度降低我方赢面的方向走，我方应规避那些对方可以大幅降低我方赢面的走法。</p><h2 id="Minimax算法"><a href="#Minimax算法" class="headerlink" title="Minimax算法"></a>Minimax算法</h2><p>称我方为<code>MAX</code>，对方为<code>MIN</code>，图示如下：</p><a id="more"></a><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/464e4b76002211e99eb2509a4c21c90b.png" alt></p><p>例如，对于如下的局势，假设从左往右搜索，根节点的数值为我方赢面（<strong>倒推值</strong>）：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/466b1b14002211e9bac5509a4c21c90b.png" alt></p><p>我方应选择中间的路线。因为，如果选择左边的路线，最差的赢面是3；如果选择中间的路线，最差的赢面是15；如果选择右边的路线，最差的赢面是1。虽然选择右边的路线可能有22的赢面，但对方也可能使我方只有1的赢面，假设对方会选择使得我方赢面最小的方向走，那么经过权衡，显然选择中间的路线更为稳妥。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/468b9c8c002211e99464509a4c21c90b.png" alt></p><p>实际上，在看右边的路线时，当发现赢面可能为1就不必再去看赢面为12、20、22的分支了，因为已经可以确定右边的路线不是最好的。这个过程就是<strong>剪枝</strong>，可以避免不必要的计算。</p><h2 id="alpha-beta-剪枝"><a href="#alpha-beta-剪枝" class="headerlink" title="$\alpha-\beta$ 剪枝"></a>$\alpha-\beta$ 剪枝</h2><p>例如，对于如下的局势，假设从左往右搜索：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/46ad4d30002211e98548509a4c21c90b.png" alt></p><p>若已知某节点的所有子节点的倒推值，则可以算出该节点的倒推值：对于<code>MAX</code>节点，取最大倒推值；对于<code>MIN</code>节点，取最小倒推值。</p><p>若已知某节点的部分子节点的倒推值，虽然不能算出该节点的倒推值，但可以算出该节点的倒推值的取值范围。同时，利用该节点的倒推值的取值范围，在搜素其子节点时，如果已经确定没有更好的走法，就不必再搜索剩余的子节点了。</p><p>记 $v$ 为节点的倒推值，且 $\alpha \leq v \leq \beta$，即 $\alpha$ 为最大下界， $\beta$ 为最小上界。当 $\alpha \geq \beta$ 时，该节点剩余的分支就不必继续搜索了（也就是可以进行剪枝了）。注意，当 $\alpha = \beta$ 时，也可以剪枝，这是因为不会有更好的结果了，但可能有更差的结果。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/46d2db78002211e9a441509a4c21c90b.png" alt></p><p>初始化时，令 $\alpha = -\infty$ ，$\beta = +\infty$ ，也就是 $-\infty \leq v \leq +\infty$。到节点A时，由于左子节点的倒推值为3，而节点A是<code>MIN</code>节点，试图找倒推值小的走法，于是将 $\beta$ 值修改为3，这是因为3小于当前的 $\beta$ 值（$\beta = +\infty$）。然后节点A的右子节点的倒推值为17，此时不修改节点A的 $\beta$ 值，这是因为17大于当前的 $\beta$ 值（$\beta = 3$）。之后，节点A的所有子节点搜索完毕，即可计算出节点A的倒推值为3。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/4700cf58002211e98666509a4c21c90b.png" alt></p><p>节点A是节点B的子节点，计算出节点A的倒推值后，可以更新节点B的倒推值范围（也就是 $\alpha$ 和 $\beta$ 值）。由于节点B是<code>MAX</code>节点，试图找倒推值大的走法，于是将 $\alpha$ 值修改为3，这是因为3大于当前的 $\alpha$值（$\alpha = +\infty$）。之后搜索节点B的右子节点C，并将节点B的 $\alpha$ 和 $\beta$ 值传递给节点C。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/472a27d0002211e9830c509a4c21c90b.png" alt></p><p>对于节点C，由于左子节点的倒推值为2，而节点C是<code>MIN</code>节点，于是将 $\beta$值修改为2。此时 $\alpha \geq \beta$，故节点C的剩余子节点就不必搜索了，因为可以确定，通过节点C并没有更好的走法。然后，节点C是<code>MIN</code>节点，将节点C的倒推值设为 $\beta$ ，也就是2。由于节点B的所有子节点搜索完毕，即可计算出节点B的倒推值为3。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/474ee0b0002211e9a394509a4c21c90b.png" alt></p><p>计算出节点B的倒推值后，节点B是节点D的一个子节点，故可以更新节点D的倒推值范围。由于节点D是<code>MIN</code>节点，于是将 $\beta$ 值修改为3。然后节点D将 $\alpha$ 和 $\beta$ 值传递给节点E，节点E又传递给节点F。对于节点F，它只有一个倒推值为15的子节点，由于15大于当前的 $\beta$ 值，而节点F为<code>MIN</code>节点，所以不更新其 $\beta$ 值，然后可以计算出节点F的倒推值为15。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/4779d910002211e9aad5509a4c21c90b.png" alt></p><p>计算出节点F的倒推值后，节点F是节点E的一个子节点，故可以更新节点E的倒推值范围。节点E是<code>MAX</code>节点，更新 $\alpha$，此时 $\alpha \geq \beta$，故可以剪去节点E的余下分支。然后，节点E是<code>MAX</code>节点，将节点E的倒推值设为 $\alpha$ ，也就是15。此时，节点D的所有子节点搜索完毕，即可计算出节点D的倒推值为3。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/47a3cda4002211e9902d509a4c21c90b.png" alt></p><p>计算出节点D的倒推值后，节点D是节点H的一个子节点，故可以更新节点H的倒推值范围。节点H是<code>MAX</code>节点，更新 $\alpha$。然后，按搜索顺序，将节点H的 $\alpha$ 和 $\beta$ 值依次传递给节点I、J、K。对于节点K，其左子节点的倒推值为2，而节点K是<code>MIN</code>节点，更新 $\beta$，此时 $\alpha \geq \beta$，故可以剪去节点K的余下分支。然后，将节点K的倒推值设为2。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/47cfb21e002211e9916c509a4c21c90b.png" alt></p><p>计算出节点K的倒推值后，节点K是节点J的一个子节点，故可以更新节点J的倒推值范围。节点J是<code>MAX</code>节点，更新 $\alpha$，但是，由于节点K的倒推值小于 $\alpha$，所以节点J的 $\alpha$ 值维持3保持不变。然后，将节点J的$\alpha$ 和 $\beta$ 值传递给节点L。由于节点L是<code>MIN</code>节点，更新 $\beta = 3$，此时 $\alpha \geq \beta$，故可以剪去节点L的余下分支，由于节点L没有余下分支，所以此处并没有实际剪枝。然后，将节点L的倒推值设为3。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/47f88870002211e99bfa509a4c21c90b.png" alt></p><p>此时，节点J的搜索子节点搜索完毕，计算出节点J的倒推值为3。由于节点J是节点I的子节点，故可以更新节点I的倒推值范围。节点I是<code>MIN</code>节点，更新 $\beta = 3$，此时，$\alpha \geq \beta$，故可以剪去节点I的余下分支。然后，将节点I的倒推值设为3。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p><a href="http://web.cs.ucla.edu/~rosen/161/notes/minimax.html" target="_blank" rel="noopener">CS 161 Recitation Notes - The Minimax Algorithm</a></p><p><a href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html" target="_blank" rel="noopener">CS 161 Recitation Notes - Minimax with Alpha Beta Pruning</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在局面确定的双人对弈里，常采用博弈树搜索。我方追求更大的赢面，而对方会设法降低我方的赢面。由于局面确定，因此可以对赢面进行评估。我方往较大赢面的方向走，同时考虑对方的走法。由于对方的走法不确定，就假设对方会选择最大程度降低我方赢面的方向走，我方应规避那些对方可以大幅降低我方赢面的走法。&lt;/p&gt;
&lt;h2 id=&quot;Minimax算法&quot;&gt;&lt;a href=&quot;#Minimax算法&quot; class=&quot;headerlink&quot; title=&quot;Minimax算法&quot;&gt;&lt;/a&gt;Minimax算法&lt;/h2&gt;&lt;p&gt;称我方为&lt;code&gt;MAX&lt;/code&gt;，对方为&lt;code&gt;MIN&lt;/code&gt;，图示如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://jlice.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Linux下实用批处理脚本</title>
    <link href="https://jlice.top/p/7q1p8/"/>
    <id>https://jlice.top/p/7q1p8/</id>
    <published>2018-12-05T09:32:45.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>经常需要在Linux下批量处理图片，想了想，还是写个实用的批处理小脚本一劳永逸。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>SRC为待处理目录；DST为目标目录，也就是保存处理后的文件的目录；SFX用于设置文件名后缀，如果为空就不修改文件名后缀。如果SRC有子目录，DST将和SRC有相同的子目录结构。脚本中的<code>convert</code>命令修改成相应的处理命令。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">SRC=/path/to/<span class="built_in">source</span></span><br><span class="line">DST=/path/to/destination</span><br><span class="line">SFX=jpg</span><br><span class="line"></span><br><span class="line">IFS_old=<span class="variable">$IFS</span></span><br><span class="line">IFS=$<span class="string">'\n'</span></span><br><span class="line"><span class="keyword">for</span> dir <span class="keyword">in</span> $(find <span class="variable">$SRC</span> -<span class="built_in">type</span> d)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mkdir -p $(<span class="built_in">echo</span> <span class="variable">$dir</span> | sed <span class="string">"s|<span class="variable">$SRC</span>|<span class="variable">$DST</span>|"</span>)</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(find <span class="variable">$SRC</span> -<span class="built_in">type</span> f)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    new_file=$(<span class="built_in">echo</span> <span class="variable">$file</span> | sed <span class="string">"s|<span class="variable">$SRC</span>|<span class="variable">$DST</span>|"</span>)</span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="variable">$SFX</span> ]]; <span class="keyword">then</span></span><br><span class="line">        new_file=<span class="variable">$&#123;new_file%.*&#125;</span>.<span class="variable">$SFX</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line">    convert <span class="variable">$file</span> <span class="variable">$new_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">IFS=<span class="variable">$IFS_old</span></span><br></pre></td></tr></table></figure><h2 id="脚本讲解"><a href="#脚本讲解" class="headerlink" title="脚本讲解"></a>脚本讲解</h2><p><code>IFS</code>是internal field separator的缩写，shell的特殊环境变量，默认是空白（空格、换行、制表符）。<code>IFS=$&#39;\n&#39;</code>设置分隔符为<code>\n</code>，这种写法不支持<code>sh</code>。之所以要设置<code>IFS</code>，是因为路径可能包含空格，在for循环时就会被截断。</p><p>使用<code>sed</code>进行替换时，不一定要使用<code>/</code>，也可以使用其它符号（如<code>|</code>、<code>#</code>等）。也就是，可以写成<code>sed &#39;s/old/new/&#39;</code>的形式，也可以写成<code>sed &#39;s|old|new|&#39;</code>的形式。在这里，由于路径中有<code>/</code>，为了方便，就是用<code>|</code>来替换<code>sed</code>命令中常使用的<code>/</code>。</p><p><code>sed</code>默认使用BRE（基本正则表达式），如果要使用ERE（扩展正则表达式），需要加上<code>-E</code>参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常需要在Linux下批量处理图片，想了想，还是写个实用的批处理小脚本一劳永逸。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;p&gt;SRC为待处理目录；DST为目标目录，也就是保存处理后的文件的目录；SFX用于设置文件名后缀，如果为空就不修改文件名后缀。如果SRC有子目录，DST将和SRC有相同的子目录结构。脚本中的&lt;code&gt;convert&lt;/code&gt;命令修改成相应的处理命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://jlice.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用ipv6 hosts</title>
    <link href="https://jlice.top/p/7q0w4/"/>
    <id>https://jlice.top/p/7q0w4/</id>
    <published>2018-12-04T16:04:35.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>一些校园网能使用ipv6，而Google、Youtube等网站支持ipv6。但是，DNS服务器一般返回的是ipv4的地址，因此，可以通过修改hosts来直接使用ipv6地址访问这些网站。</p><p>可以先在<a href="https://test-ipv6.com/" target="_blank" rel="noopener">IPv6 连接测试</a>来测试是否接入了ipv6。</p><p>在GitHub上有<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts" target="_blank" rel="noopener">ipv6-hosts</a>，用这个替换系统默认的hosts文件即可直接使用ipv6地址来访问这些网站。</p><a id="more"></a><p>然而，在使用过程中发现stackoverflow.com不能正常使用了，因此，需要删除stackoverflow.com相关条目，用ipv4访问stackoverflow.com就正常了。</p><p>写这篇文章主要是因为，前一段时间Youtube视频看不了了，通过浏览器开发者工具发现是googlevideo.com访问不了的原因，于是设置了下googlevideo.com相关的hosts。然后今天Youtube直接不能访问了，于是想了想，还是写一个自动更新hosts的小脚本吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">curl -s https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts &gt; /tmp/hosts.tmp</span><br><span class="line">FILTERS=(</span><br><span class="line">  googlevideo.com</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> <span class="variable">$FILTERS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sed -n <span class="string">"/"</span><span class="variable">$url</span><span class="string">"/p"</span> /tmp/hosts.tmp &gt; /etc/hosts</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">sed -i <span class="string">'s/^M//g'</span> /etc/hosts</span><br><span class="line">cat /etc/hosts.bak &gt;&gt; /etc/hosts</span><br><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><p>由于我自己设置了一些hosts，不想被覆盖，因此把这些hosts放在了/etc/hosts.bak。</p><p>这个脚本里比较特殊的一点是<code>^M</code>，这个其实是<code>\r</code>，脚本里的<code>^M</code>是通过<code>CTRL+V CTRL+M</code>来输入的。关于这个字符的移除参考：<br><a href="https://www.cyberciti.biz/faq/sed-remove-m-and-line-feeds-under-unix-linux-bsd-appleosx/" target="_blank" rel="noopener">sed Delete / Remove ^M Carriage Return (Line Feed / CRLF) on Linux or Unix - nixCraft</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些校园网能使用ipv6，而Google、Youtube等网站支持ipv6。但是，DNS服务器一般返回的是ipv4的地址，因此，可以通过修改hosts来直接使用ipv6地址访问这些网站。&lt;/p&gt;
&lt;p&gt;可以先在&lt;a href=&quot;https://test-ipv6.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IPv6 连接测试&lt;/a&gt;来测试是否接入了ipv6。&lt;/p&gt;
&lt;p&gt;在GitHub上有&lt;a href=&quot;https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ipv6-hosts&lt;/a&gt;，用这个替换系统默认的hosts文件即可直接使用ipv6地址来访问这些网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://jlice.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《SQL入门经典》学习笔记</title>
    <link href="https://jlice.top/p/7q0if/"/>
    <id>https://jlice.top/p/7q0if/</id>
    <published>2018-12-04T07:51:59.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>这本书总体上来讲还是比较简单的，SQL入门还是不难的。使用了三种数据库，语法有所不同，有点混乱。在看书的过程中记录了一些笔记，以便查阅吧。就是下面这本：</p><p align="center">  <img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/4621907a002211e994a5509a4c21c90b.jpg" alt="SQL入门经典" width="350"></p><a id="more"></a><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul><li><code>=</code>相等</li><li><code>&lt;&gt;</code>, <code>!=</code> 不等</li><li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li><li><code>IS NULL</code>, <code>IS NOT NULL</code></li><li><code>BETWEEN</code> 介于（包含端点） <code>NOT BETWEEN</code></li><li><code>IN</code> 值在列表中, <code>NOT IN</code></li><li><code>LIKE</code> 通配符匹配：<code>%</code>（&gt;0个字符）, <code>_</code>（1个字符）, <code>NOT LIKE</code></li><li><code>EXISTS</code>, <code>NOT EXISTS</code></li><li><code>UNIQUE</code>, <code>NOT UNIQUE</code></li><li><code>ALL</code>, <code>ANY</code>, <code>SOME</code>（<code>ANY</code>的别名）</li><li><code>AND</code>, <code>OR</code></li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 算术运算</li></ul><h2 id="汇总查询"><a href="#汇总查询" class="headerlink" title="汇总查询"></a>汇总查询</h2><p><code>COUNT</code>, <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>AVG</code></p><h2 id="数据排序与分组"><a href="#数据排序与分组" class="headerlink" title="数据排序与分组"></a>数据排序与分组</h2><p><code>GROUP BY</code>, <code>ORDER BY</code></p><p><code>CUBE</code>, <code>ROLLUP</code> </p><p><code>WHERE</code>子句设定<code>SELECT</code>选择字段的条件；<code>HAVING</code>子句设定<code>GROUP BY</code>子句形成分组的条件。</p><h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><ul><li>拼接字符串：<code>||</code>(Oracle), <code>+</code>(SQL Sever), <code>CONCAT</code>(MySQL)</li><li><code>TRANSLATE</code> 对应替换（类似于<code>tr</code>命令）</li><li><code>REPLACE</code> 替换</li><li><code>UPPER</code>, <code>LOWER</code></li><li><code>SUBSTR</code>, <code>SUBSTRING</code> 字符串子串</li><li><code>INSTR</code> 查找，返回位置</li><li><code>LTRIM</code>, <code>RTRIM</code> 在一侧切除字符串</li><li><code>DECODE</code> 在字符串中搜索字符串，如果找到了就显示另一个字符串</li><li><code>IFNULL</code> 如果是NULL就用替代值  <code>COALESCE</code> 依次检查，返回第一个非NULL值</li><li><code>LPAD</code>, <code>RPAD</code> 在一侧填充</li><li><code>ASCII</code> ASCII值</li><li>算术函数：<code>ABS</code>, <code>ROUND</code>, <code>SQRT</code>, <code>SIGN</code>（符号函数）, <code>POWER</code>, <code>CEIL</code>, <code>FLOOR</code>, <code>EXP</code></li><li>与数字转换（有的可以隐式转换）：<code>TO_NUMBER</code>, <code>STR</code>, <code>TO_CHAR</code></li></ul><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>不同的实现有所差别</p><p>MySQL：<code>NOW</code>, <code>DATE_ADD</code>, <code>STR_TO_DATE</code></p><h2 id="在查询里结合表"><a href="#在查询里结合表" class="headerlink" title="在查询里结合表"></a>在查询里结合表</h2><p>等值结合/内部结合：利用通用字段（一般是主键）结合两个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE1.COLUMN1, TABLE2.COLUMN2...</span><br><span class="line"><span class="keyword">FROM</span> TABLE1, TABLE2</span><br><span class="line"><span class="keyword">WHERE</span> TABLE1.COLUMN_NAME = TABLE2.COLUMN_NAME</span><br></pre></td></tr></table></figure><p>将上面的<code>=</code>改为<code>!=</code>就是不等值结合、</p><p>外部结合的一般语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM TABLE1</span><br><span class="line">&#123;RIGHT | LEFT | FULL&#125; [OUTER] JOIN TABLE2</span><br><span class="line">ON TABLE1.COLUMN_NAME = TABLE2.COLUMN_NAME</span><br></pre></td></tr></table></figure><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询就是在另一个查询里执行的查询，用于进一步设置查询的条件。子查询不能使用<code>ORDER BY</code>。</p><p>关联子查询是依赖主查询里的信息的子查询，即子查询里能引用主查询里的表（类似于闭包）。</p><h2 id="组合多个查询"><a href="#组合多个查询" class="headerlink" title="组合多个查询"></a>组合多个查询</h2><p>组合查询：有两个或多个<code>SELECT</code>语句</p><p>组合操作符（位于两个<code>SELECT</code>语句之间）：</p><ul><li><code>UNION</code> 结合，不包含重复</li><li><code>UNION ALL</code> 结合，包含重复</li><li><code>INTERSECT</code> 返回前一个<code>SELECT</code>语句里与后一个<code>SELECT</code>语句里一样的记录</li><li><code>EXCEPT</code>  返回前一个<code>SELECT</code>语句里有但后一个<code>SELECT</code>语句里没有的记录</li></ul><p><code>ORDER BY</code>可以用于组合查询，但只能用于对全部查询结果的排序；<code>GROUP BY</code>可以用于组合查询中每个<code>SELECT</code>语句，也可以用于全部查询结果；<code>HAVING</code>可以用于组合查询里每个<code>SELECT</code>语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COLUMN1</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">&#123;<span class="keyword">UNION</span> | <span class="keyword">UNION</span> <span class="keyword">ALL</span> | <span class="keyword">EXCEPT</span> | <span class="keyword">INTERSECT</span>&#125;</span><br><span class="line"><span class="keyword">SELECT</span> COLUMN1</span><br><span class="line"><span class="keyword">FROM</span> TABLE1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure><h2 id="高级SQL主题"><a href="#高级SQL主题" class="headerlink" title="高级SQL主题"></a>高级SQL主题</h2><p>【存储过程】</p><p>存储过程是一组相关联的SQL语句，通常被称为函数和子程序，利用存储过程可以实现过程化编程</p><p>MySQL创建存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> PROCEDURE_NAME</span><br><span class="line">(ARGUMENT1 &#123;<span class="keyword">IN</span> | <span class="keyword">OUT</span> | <span class="keyword">IN</span> <span class="keyword">OUT</span>&#125; <span class="keyword">TYPE</span>, ARGUMENT2 &#123;<span class="keyword">IN</span> | <span class="keyword">OUT</span> | <span class="keyword">IN</span> <span class="keyword">OUT</span>&#125; <span class="keyword">TYPE</span>)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PROCEDURE_BODY</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>【触发器】</p><p>MySQL创建触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRIGGER_NAME</span><br><span class="line">&#123;<span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span>&#125;</span><br><span class="line">&#123;<span class="keyword">INSERT</span> | <span class="keyword">UPDATE</span> | <span class="keyword">DELETE</span>&#125;</span><br><span class="line"><span class="keyword">ON</span> TABLE_NAME</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">SQL_STATEMENTS</span><br></pre></td></tr></table></figure><p>MySQL里，<code>FOR EACH ROW</code>可以在每条影响的记录时均执行一次触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> TRIGGER_NAME</span><br><span class="line"><span class="keyword">ON</span> TABLE_NAME</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">SQL_STATEMENTS</span><br></pre></td></tr></table></figure><p>删除触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> TRIGGER_NAME</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书总体上来讲还是比较简单的，SQL入门还是不难的。使用了三种数据库，语法有所不同，有点混乱。在看书的过程中记录了一些笔记，以便查阅吧。就是下面这本：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://blog-1256819794.cos.ap-shanghai.myqcloud.com/4621907a002211e994a5509a4c21c90b.jpg&quot; alt=&quot;SQL入门经典&quot; width=&quot;350&quot;&gt;
&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://jlice.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>【实验楼】Redis基础教程——学习笔记</title>
    <link href="https://jlice.top/p/7pzge/"/>
    <id>https://jlice.top/p/7pzge/</id>
    <published>2018-12-03T09:02:15.000Z</published>
    <updated>2019-03-22T12:37:10.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>设置值：<code>set key value</code><br>获取值：<code>get key</code><br>没有相同key时才设置值：<code>set key newval nx</code><br>拥有相同key时才设置值：<code>set key newval xx</code>  </p><p>增加1：<code>incr key</code><br>增加x：<code>incrby key x</code>  </p><a id="more"></a><p>同时设置多个值：<code>mset key1 value1 key2 value2</code><br>同时获取多个值：<code>mget key1 key2</code>  </p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>PUSH: <code>lpush</code> 插入新元素到头部；<code>rpush</code> 插入新元素到尾部（一次可以push多个元素）<br>POP: <code>lpop</code> 删除头部元素；<code>rpop</code> 删除尾部元素</p><p>查看列表所有元素：<code>lrange key 0 -1</code><br>清空列表元素/删除列表：<code>del key</code></p><h3 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h3><p>HMSET命令设置一个多域的hash表：<code>hmset key k1 v1 k2 v2</code><br>HGET命令获取指定的单域：<code>hget key k1</code><br>HMGET命令获取指定的多域：<code>hmget key k1 k2</code><br>HGETALL命令获取指定key的所有信息：<code>hgetall key</code></p><p>可以根据需要对hash表的表项进行单独的操作，如HINCRBY：<code>hincrby key k1 x</code></p><h3 id="无序集合"><a href="#无序集合" class="headerlink" title="无序集合"></a>无序集合</h3><p>无序集合不包含重复元素，添加、删除、测试元素存在：O(1)</p><p>向无序集合中添加元素：<code>sadd key x1 x2 x3</code><br>查看集合元素：<code>smembers key</code><br>查看集合是否包含元素x：<code>sismember key x</code></p><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合不包含重复元素，添加、删除、更新元素：O(logN)。有序集合需要元素评分来决定元素次序。</p><p>ZADD添加元素: <code>zadd key score value</code><br>ZRANGE查看元素：<code>zrange key 0 -1</code><br>ZREVRANGE逆序查看元素：<code>zrevrange key 0 -1</code><br>使用WITHSCORES参数返回评分：<code>zrange key 0 -1 withscores</code>  </p><h2 id="Redis系统管理"><a href="#Redis系统管理" class="headerlink" title="Redis系统管理"></a>Redis系统管理</h2><p><code>EXISTS</code> 判断key是否存在<br><code>DEL</code> 删除key<br><code>TYPE</code> 返回key元素的数据类型<br><code>KEYS</code> 返回通配符匹配的key列表<br><code>RANDOMKEY</code> 随机获得一个已经存在的key<br><code>CLEAR</code> 清屏<br><code>RENAME</code> 改key的名字，新键如果存在将被覆盖<br><code>RENAMENX</code> 改key的名字，新建如果存在则更新失败<br><code>DBSIZE</code> 返回当前数据库的key的总数  </p><p><code>EXPIRE</code> 设置某个key的过期时间（秒），也可以在SET命令中设置过期时间：<code>set key value ex seconds</code><br><code>TTL</code> 查询还有多长时间过期  </p><p><code>FLUSHDB</code> 清空当前数据库中的所有键<br><code>FLUSHALL</code> 清空所有数据库中的所有键  </p><p><code>CONFIG GET</code> 读取配置<br><code>CONFIG SET</code> 更改配置<br><code>AUTH</code> 使用密码认证<br><code>CONFIG RESETSTAT</code> 重置数据统计报告  </p><p><code>INFO</code> 查询Redis相关信息</p><h2 id="Redis的高级应用"><a href="#Redis的高级应用" class="headerlink" title="Redis的高级应用"></a>Redis的高级应用</h2><p>认证方式：</p><ul><li>登录时 <code>redis-cli -a password</code></li><li>登录后 <code>auth password</code></li></ul><p>事务：</p><ul><li>开始事务：<code>multi</code></li><li>运行事务：<code>exec</code></li></ul><p>两种持久化方式：</p><ul><li>snapshotting（快照，默认方式）：将数据存放到文件</li><li>append-only file（aof）：将读写操作存放到文件中</li></ul><p><code>SAVE</code> 将数据写入磁盘</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis数据类型&quot;&gt;&lt;a href=&quot;#Redis数据类型&quot; class=&quot;headerlink&quot; title=&quot;Redis数据类型&quot;&gt;&lt;/a&gt;Redis数据类型&lt;/h2&gt;&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;p&gt;设置值：&lt;code&gt;set key value&lt;/code&gt;&lt;br&gt;获取值：&lt;code&gt;get key&lt;/code&gt;&lt;br&gt;没有相同key时才设置值：&lt;code&gt;set key newval nx&lt;/code&gt;&lt;br&gt;拥有相同key时才设置值：&lt;code&gt;set key newval xx&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;增加1：&lt;code&gt;incr key&lt;/code&gt;&lt;br&gt;增加x：&lt;code&gt;incrby key x&lt;/code&gt;  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习CUDA配置指南</title>
    <link href="https://jlice.top/p/7p7cg/"/>
    <id>https://jlice.top/p/7p7cg/</id>
    <published>2018-11-08T01:52:29.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看显卡信息"><a href="#查看显卡信息" class="headerlink" title="查看显卡信息"></a>查看显卡信息</h2><p>要使用CUDA，必须要有NVIDIA显卡，可以使用<code>lspci</code>命令来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lspci | grep NVIDIA</span><br><span class="line">02:00.0 VGA compatible controller: NVIDIA Corporation Device 1b06 (rev a1)</span><br><span class="line">02:00.1 Audio device: NVIDIA Corporation Device 10ef (rev a1)</span><br><span class="line">03:00.0 VGA compatible controller: NVIDIA Corporation Device 1b06 (rev a1)</span><br><span class="line">03:00.1 Audio device: NVIDIA Corporation Device 10ef (rev a1</span><br></pre></td></tr></table></figure><p>例如，上面显示显卡是NVIDIA的，<code>1b06</code>是deviceID，是厂商给自己某个型号的产品分配的ID。那么，如何通过deviceID来查询产品型号呢？网上有一些deviceID的数据库，例如：<a href="https://envytools.readthedocs.io/en/latest/hw/pciid.html" target="_blank" rel="noopener">envytools</a>。在此页面可查得<code>1b06</code>的产品型号为GeForce GTX 1080 Ti。</p><a id="more"></a><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><p>以Ubuntu为例，可以使用命令<code>ubuntu-drivers list</code>来查看合适的显卡驱动，安装较新的驱动即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ubuntu-drivers list</span><br><span class="line">nvidia-390</span><br><span class="line">nvidia-384</span><br><span class="line">nvidia-387</span><br><span class="line">nvidia-396</span><br><span class="line">nvidia-410</span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install nvidia-410</span><br></pre></td></tr></table></figure><p>如果输出为空，可以尝试换apt的软件源或添加ppa。另外，也可以到<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">NVIDIA 驱动程序下载</a>下载驱动并安装：</p><p>以Ubuntu为例，在选择操作系统时，如果有Ubuntu的选项就选Ubuntu而不是Linux，前者下载的是<code>deb</code>格式的安装包，后者是<code>run</code>格式。</p><p>对于<code>deb</code>格式，使用如下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i xxx.deb</span><br></pre></td></tr></table></figure><p>对于<code>run</code>格式，需要屏蔽Ubuntu自带的开源显卡驱动<code>nouveau</code>，关闭X环境（不带图形界面，仅有字符界面），然后安装。由于这种安装方式较为繁琐，且容易出错，因此尽量采用前面的安装方式。详细安装方法见「安装CUDA」一节的“官方安装指南”。</p><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>到<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">CUDA官方下载</a>可以下载最新版本的cuda，也可以到<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">CUDA Toolkit Archive | NVIDIA Developer</a>下载各版本cuda。</p><p>选择合适的操作系统，安装类别推荐<code>network</code>，不推荐<code>runfile</code>。</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/45f9ca8c002211e9b8a5509a4c21c90b.jpg" alt></p><p>然后按照Installation Instructions安装即可。</p><p>需要注意的是，最后一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cuda</span><br></pre></td></tr></table></figure><p>会安装最新版本的cuda，且有新版本时可升级到最新。如果想装某个版本的cuda，可以指定版本，并且会保持该版本，除非后续又安装了其它版本。例如指定版本cuda 9.0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cuda-9-0</span><br></pre></td></tr></table></figure><p>然后设置<code>PATH</code>和<code>LD_LIBRARY_PATH</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/cuda/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:/usr/<span class="built_in">local</span>/cuda/extras/CUPTI/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>可以写入到<code>/etc/profile.d/cuda-env.sh</code>，然后运行<code>source</code>使之生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile.d/cuda-env.sh</span><br></pre></td></tr></table></figure><p>官方安装指南可以参考：</p><blockquote><p><strong>官方安装指南</strong></p></blockquote><p><a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" target="_blank" rel="noopener">Installation Guide Linux :: CUDA Toolkit Documentation</a></p><h2 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h2><p>到CUDNN官网下载<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">NVIDIA cuDNN | NVIDIA Developer</a>最新版本cudnn，可以到<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">cuDNN Archive | NVIDIA Developer</a>下载各版本cudnn。下载需要登录，选择cuda所对应的版本，Runtime Library和Developer Library都安装。</p><p>以Ubuntu为例，推荐使用<code>deb</code>格式的安装文件。</p><p>手动安装需注意：cudnn包含cudnn的库和头文件，需要确保库位于默认位置或<code>LD_LIBRARY_PATH</code>，否则需要将cudnn的库所在路径加入<code>LD_LIBRARY_PATH</code>。</p><blockquote><p><strong>说明</strong></p></blockquote><p>除了设置<code>LD_LIBRARY_PATH</code>，也可以使用<code>ldconfig</code>来管理动态链接库的路径。</p><h2 id="NCCL、TensorRT"><a href="#NCCL、TensorRT" class="headerlink" title="NCCL、TensorRT"></a>NCCL、TensorRT</h2><p>可以到<a href="https://developer.nvidia.com/nccl" target="_blank" rel="noopener">NVIDIA Collective Communications Library (NCCL) | NVIDIA Developer</a>下载安装NCCL。</p><p>TensorRT官方安装指南：<br><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-install-guide/index.html" target="_blank" rel="noopener">TensorRT Installation Guide :: Deep Learning SDK Documentation</a></p><p>安装比较简单，在此不赘述。</p><blockquote><p><strong>说明</strong></p></blockquote><p>需要注意本地repo的概念，安装了本地repo实际上并没有安装该repo里的包，需要先进行<code>apt update</code>，然后仍然需要使用<code>apt install</code>进行安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看显卡信息&quot;&gt;&lt;a href=&quot;#查看显卡信息&quot; class=&quot;headerlink&quot; title=&quot;查看显卡信息&quot;&gt;&lt;/a&gt;查看显卡信息&lt;/h2&gt;&lt;p&gt;要使用CUDA，必须要有NVIDIA显卡，可以使用&lt;code&gt;lspci&lt;/code&gt;命令来查看：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lspci | grep NVIDIA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;02:00.0 VGA compatible controller: NVIDIA Corporation Device 1b06 (rev a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;02:00.1 Audio device: NVIDIA Corporation Device 10ef (rev a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;03:00.0 VGA compatible controller: NVIDIA Corporation Device 1b06 (rev a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;03:00.1 Audio device: NVIDIA Corporation Device 10ef (rev a1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，上面显示显卡是NVIDIA的，&lt;code&gt;1b06&lt;/code&gt;是deviceID，是厂商给自己某个型号的产品分配的ID。那么，如何通过deviceID来查询产品型号呢？网上有一些deviceID的数据库，例如：&lt;a href=&quot;https://envytools.readthedocs.io/en/latest/hw/pciid.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;envytools&lt;/a&gt;。在此页面可查得&lt;code&gt;1b06&lt;/code&gt;的产品型号为GeForce GTX 1080 Ti。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://jlice.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>撸了个LeetCode题解仓库自动生成与发布的工具</title>
    <link href="https://jlice.top/p/7odvq/"/>
    <id>https://jlice.top/p/7odvq/</id>
    <published>2018-10-12T13:26:00.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到有不少人在GitHub展示自己的LeetCode题解。其实我自己也在GitHub记录了自己的LeetCode题解，但是，从做题到整理，需要很多时间。本来刷题就需要时间，也够累的，还要整理，再写出来，一道题得花上好久。</p><p>最近在LeetCode上刷了上百道题目，当然，不少是Easy难度的。如果让我手动去整理，我觉得太费时间了。我一直贯彻一种理念，简单不麻烦的事容易坚持。于是，我就想着，是否能用程序来去做这些呢？</p><p>以前在刷题的时候没注意到右侧的Notes，后来偶尔注意到了，突发灵感，这个不正好可以用来写解题思路吗？于是，我就希望有个工具能整理我刷过的题目和我的解答，还有Notes。但是，找了一圈，没发现合适的，所以，干脆就自己花了大概一天半的时间撸了一个：<a href="https://github.com/jlice/leetcode-publisher" target="_blank" rel="noopener">leetcode-publisher</a></p><a id="more"></a><p>说一下这个工具和别的类似的工具的不同点吧。在GitHub上看到有人做过类似的工具，但是是基于headless的浏览器做的，我觉得这种方式不够优雅。其实LeetCode的请求构造并没有很麻烦，主要是csrftoken，在cookies里有，在请求头要传<code>x-csrftoken</code>和<code>referer</code>。另外，类似的LeetCode题解仓库其实放的主要是程序源代码，这并不是我想要的。因为Markdown格式可以很方便插入代码，而且，刷题的代码并不长，放在Markdown里，和题目与笔记一起，更为合适。</p><p>当然，关于这个工具更具体的信息还是到GitHub去看吧～</p><blockquote><p><a href="https://github.com/jlice/leetcode-publisher" target="_blank" rel="noopener">jlice/leetcode-publisher: Automatically generate and publish LeetCode solution repository（LeetCode题解仓库自动生成与发布）</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结下做这个小项目的过程中遇到的一些困难与解决方案。</p><h3 id="csrftoken"><a href="#csrftoken" class="headerlink" title="csrftoken"></a>csrftoken</h3><p>CSRF是跨站请求伪造，因为server不能给其它domain设置cookies，所以可以在请求时带上一个随机token来验证是否跨域。LeetCode要求请求头要有<code>x-csrftoken</code>和<code>referer</code>。</p><h3 id="unicode字符串"><a href="#unicode字符串" class="headerlink" title="unicode字符串"></a>unicode字符串</h3><p>在获取提交的代码时，是通过正则表达式提取网页实现的，网页里用的unicode编码。比如，换行符是<code>\u000A</code>，但是，通过正则表达式提取，会被视为字符串<code>\\u000A</code>。问题是，如何把形如<code>\\u000A</code>的字符串转换成对应unicode字符（<code>\n</code>）。一开始我是想的替换和eval，结果各种试还是不行。最终想到的方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\u000A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'\\u000A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = s.encode(<span class="string">'utf-8'</span>).decode(<span class="string">'unicode-escape'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'\n'</span></span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>当然，还遇到了其它的一些问题，不过相对比较好解决。</p><p>比如说，HTTP 429。HTTP 429表示一定时间内请求太多。这个容易处理，捕获HTTPError，出错时等待一段时间再试即可。</p><p>另外，用<code>subprocess</code>调用Shell命令<code>cd</code>切换目录时在下一条命令并不生效，因为每条命令其实是相对独立的！要用<code>os.chdir</code>来切换工作目录！</p><p>为了让这个项目更有范，写英文README也是费了心思，毕竟英语写作太差了，最后还是借助Google翻译，唔。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看到有不少人在GitHub展示自己的LeetCode题解。其实我自己也在GitHub记录了自己的LeetCode题解，但是，从做题到整理，需要很多时间。本来刷题就需要时间，也够累的，还要整理，再写出来，一道题得花上好久。&lt;/p&gt;
&lt;p&gt;最近在LeetCode上刷了上百道题目，当然，不少是Easy难度的。如果让我手动去整理，我觉得太费时间了。我一直贯彻一种理念，简单不麻烦的事容易坚持。于是，我就想着，是否能用程序来去做这些呢？&lt;/p&gt;
&lt;p&gt;以前在刷题的时候没注意到右侧的Notes，后来偶尔注意到了，突发灵感，这个不正好可以用来写解题思路吗？于是，我就希望有个工具能整理我刷过的题目和我的解答，还有Notes。但是，找了一圈，没发现合适的，所以，干脆就自己花了大概一天半的时间撸了一个：&lt;a href=&quot;https://github.com/jlice/leetcode-publisher&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode-publisher&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://jlice.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中list的remove方法的坑</title>
    <link href="https://jlice.top/p/7o05h/"/>
    <id>https://jlice.top/p/7o05h/</id>
    <published>2018-09-30T04:53:31.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>在做LeetCode上的一道非常简单的题目<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/" target="_blank" rel="noopener">find-all-numbers-disappeared-in-an-array</a>时，竟然做错了。经过Debug发现，Python在移除list中的True把1也移除了。为了说明这个问题，下面是示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以发现，移除True时，把1也给移除了，但是2没有被移除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="literal">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>而当list里的元素是True，移除1时把True也给移除了。</p><p>因此，可以看出，True和1是等同的。做类似的实验，False和0是等同的。甚至True和False也可以进行算术运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> == <span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> + <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做LeetCode上的一道非常简单的题目&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;find-all-numbers-disappeared-in-an-array&lt;/a&gt;时，竟然做错了。经过Debug发现，Python在移除list中的True把1也移除了。为了说明这个问题，下面是示例代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a.remove(&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a.remove(&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://jlice.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>记因内核版本错误导致U盘不能识别的问题解决</title>
    <link href="https://jlice.top/p/7l9mo/"/>
    <id>https://jlice.top/p/7l9mo/</id>
    <published>2018-07-03T12:48:29.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>U盘插上电脑，发现没有自动挂载。然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fdisk -l</span><br></pre></td></tr></table></figure><p>一看，发现并没有U盘所对应的设备，也就是U盘不能识别了！以前从没在Linux上遇到这种问题，通过查资料得知，要识别U盘，需要装载usb-storage模块。</p><p>于是，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod | grep usb</span><br></pre></td></tr></table></figure><p>发现确实没有usb-storage模块。</p><p>为了判断U盘是否物理损坏导致系统无法“感知”U盘的存在，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo udevadm monitor --udev</span><br></pre></td></tr></table></figure><p>发现U盘插拔时有反应。</p><a id="more"></a><p>然后运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe usb-storage</span><br><span class="line">modprobe: FATAL: Module usb-storage not found in directory /lib/modules/4.14.48-2-MANJARO</span><br></pre></td></tr></table></figure><p>尝试装载usb-storage模块，结果报错。</p><p>查看/lib/modules/目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls /lib/modules </span><br><span class="line">4.14.40-rt30-MANJARO  extramodules-4.14-MANJARO</span><br><span class="line">4.14.52-1-MANJARO     extramodules-4.14-rt-MANJARO</span><br></pre></td></tr></table></figure><p>发现并没有4.14.48-2-MANJARO。在Manjaro设置管理器里查看内核：</p><p><img src="https://blog-1256819794.cos.ap-shanghai.myqcloud.com/45d2c47e002211e99e66509a4c21c90b.jpg" alt></p><p>发现当前内核版本为4.14.52-1。但是，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure><p>却显示内核版本为4.14.48-2-MANJARO。这也难怪modprobe会到/lib/modules/4.14.48-2-MANJARO目录下去找usb-storage模块。</p><p>通过查询modprobe的manpage，发现可以指定版本。运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo modprobe --<span class="built_in">set</span>-version=4.14.52-1-MANJARO usb-storage</span><br></pre></td></tr></table></figure><p>U盘终于自动挂载了！</p><p>为了启动时使用4.14.52-1版本的内核，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-grub</span><br></pre></td></tr></table></figure><p>来更新grub，重启后再运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure><p>显示内核版本为4.14.52-1-MANJARO，U盘也能自动挂载，运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod | grep usb</span><br></pre></td></tr></table></figure><p>也有usb-storage模块，问题解决。</p><p>【后记】更新内核后最好重启下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;U盘插上电脑，发现没有自动挂载。然后运行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo fdisk -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一看，发现并没有U盘所对应的设备，也就是U盘不能识别了！以前从没在Linux上遇到这种问题，通过查资料得知，要识别U盘，需要装载usb-storage模块。&lt;/p&gt;
&lt;p&gt;于是，运行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ lsmod | grep usb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发现确实没有usb-storage模块。&lt;/p&gt;
&lt;p&gt;为了判断U盘是否物理损坏导致系统无法“感知”U盘的存在，运行命令&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo udevadm monitor --udev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发现U盘插拔时有反应。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://jlice.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PPM、PGM、PBM图像格式剖析</title>
    <link href="https://jlice.top/p/7l2u9/"/>
    <id>https://jlice.top/p/7l2u9/</id>
    <published>2018-06-27T10:09:09.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然需要用到<code>PPM</code>这个图像文件格式，之前没见过，在此记录一下。</p><p><code>PPM</code>、<code>PGM</code>、<code>PBM</code>这三个图像文件格式很少见，其实也不难，分别用于彩色图像、灰度图像、二值图像。这里以<code>PPM</code>格式为例。</p><p><code>PPM</code>格式有两种类型：字节码和ASCII。前者是二进制文件，后者是纯文本文件。</p><p>使用<code>convert</code>命令可以将图像转为<code>PPM</code>格式：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字节码</span></span><br><span class="line">$ convert xxx.jpg xxx.ppm</span><br><span class="line"><span class="comment"># ASCII</span></span><br><span class="line">$ convert xxx.jpg -compress none xxx.ppm</span><br></pre></td></tr></table></figure><p>ASCII类型的<code>PPM</code>文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P3</span><br><span class="line">1305 1305</span><br><span class="line">255</span><br><span class="line">229 232 237 228 231 236 ...</span><br></pre></td></tr></table></figure><p>第1行是<code>P3</code>，第2行是图像大小，第3行是最大值，一般是<code>255</code>。从第4行起就是每个像素的颜色值了，像素顺序一般是从左到右、从上到下，通道顺序一般是RGB。</p><p>字节码类型的<code>PPM</code>文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 36 0A 31 33 30 35 20 31 33 30 35 0A 32 35 35 0A E5 E8 ED E4 E7 EC ...</span><br></pre></td></tr></table></figure><p>最开始的<code>50 36</code>对应ASCII为<code>P6</code>，<code>31 33 30 35</code>对应ASCII为<code>1305</code>。<code>32 35 35</code>对应ASCII为<code>255</code>。后面的像素值以十六进制表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ bc -q</span><br><span class="line">obase=10</span><br><span class="line">ibase=16</span><br><span class="line">E5</span><br><span class="line">229</span><br><span class="line">E8</span><br><span class="line">232</span><br><span class="line">ED</span><br><span class="line">237</span><br></pre></td></tr></table></figure><p>Python的<code>Pillow</code>库可以读取、存储字节码类型的<code>PPM</code>格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储PPM格式</span></span><br><span class="line">im = Image.open(<span class="string">'xxx.jpg'</span>)</span><br><span class="line">im.save(<span class="string">'xxx.ppm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取PPM格式</span></span><br><span class="line">im = Image.open(<span class="string">'xxx.ppm'</span>)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure><p><code>PGM</code>头部用<code>P2</code>和<code>P5</code>分别表示ASCII类型和字节码类型；<code>PBM</code>头部用<code>P1</code>和<code>P4</code>分别表示ASCII类型和字节码类型，但没有像<code>PPM</code>第3行的最大值，ASCII类型的像素值都是0或1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天突然需要用到&lt;code&gt;PPM&lt;/code&gt;这个图像文件格式，之前没见过，在此记录一下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PPM&lt;/code&gt;、&lt;code&gt;PGM&lt;/code&gt;、&lt;code&gt;PBM&lt;/code&gt;这三个图像文件格式很少见，其实也不难，分别用于彩色图像、灰度图像、二值图像。这里以&lt;code&gt;PPM&lt;/code&gt;格式为例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PPM&lt;/code&gt;格式有两种类型：字节码和ASCII。前者是二进制文件，后者是纯文本文件。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;convert&lt;/code&gt;命令可以将图像转为&lt;code&gt;PPM&lt;/code&gt;格式：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用油猴脚本显示扇贝网真实打卡日记</title>
    <link href="https://jlice.top/p/7kmxm/"/>
    <id>https://jlice.top/p/7kmxm/</id>
    <published>2018-06-13T02:34:46.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间发现扇贝网页版显示的打卡日记和手机上看到的不一致，感觉应该是网页版开发滞后的原因。这种不一致给查卡带来了诸多不便，于是就设法解决该问题。</p><p>起初我想到的方案是做一个静态页面放到对象存储上，然后对象存储开启静态服务，静态页面通过Ajax请求手机版的RESTful接口获取数据，然后生成打卡日记。不过，通过反复试验发现这种方法行不通。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(url, function(data)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>直接使用Ajax请求会报错：</p><a id="more"></a><p>No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</p><p>这是因为服务器不允许跨站。</p><p>然后接触到了用JSONP来进行跨站请求。因为js脚本可以跨站，像静态博客的评论功能就是用的跨站js脚本，JSONP的思路是在请求的地址上携带一个callback参数，服务端以这个callback参数作为函数名包裹JSON数据，然后在返回数据时调用这个函数，就把JSON数据传过来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是，使用JSONP的前提同样是需要服务器端的配合。假如服务器端不适配JSONP，也就是不返回包裹JSON数据的函数，而是依旧返回JSON，那么JSON数据就会被视为javascript脚本运行，会报错：</p><p>Uncaught SyntaxError: Unexpected token :</p><p>然后想到iframe也可以跨站，于是试试iframe，结果发现依然是想多了：</p><p>Refused to display ‘<em>*</em>‘ in a frame because it set ‘X-Frame-Options’ to ‘deny’.</p><p>也就是iframe也是需要服务器端配合。假如服务器端不允许iframe，那么iframe便不能跨站。</p><p>跨站请求其实也比较危险，例如XSS、CSRF。于是，我决定不通过跨站请求，而是利用油猴脚本来实现我的需求，顺便补充了点jQuery。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         显示真实打卡日记</span></span><br><span class="line"><span class="comment">// @namespace    https://www.shanbay.com/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  显示时区、真实打卡日记、打卡时间</span></span><br><span class="line"><span class="comment">// @author       文剑木然</span></span><br><span class="line"><span class="comment">// @match        https://www.shanbay.com/checkin/user/*</span></span><br><span class="line"><span class="comment">// @grant        MIT</span></span><br><span class="line"><span class="comment">// @require      https://static.baydn.com/static/scripts/jquery-1.7.2.min.js</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">window</span>.location.href</span><br><span class="line">                    .replace(<span class="string">'www.shanbay.com'</span>, <span class="string">'www.shanbay.com/api/v1'</span>)</span><br><span class="line">                    .replace(<span class="string">'?page'</span>, <span class="string">'?ipp=10&amp;page'</span>);</span><br><span class="line">    $.<span class="keyword">get</span>(url, function(json)&#123;</span><br><span class="line">        <span class="comment">// 显示时区</span></span><br><span class="line">        <span class="keyword">var</span> timezone = json.data[<span class="number">0</span>].user.timezone;</span><br><span class="line">        <span class="keyword">if</span>(json.data.length &gt; <span class="number">0</span> &amp;&amp; timezone !== <span class="string">'Asia/Shanghai'</span>)&#123;</span><br><span class="line">            $(<span class="string">'h2'</span>).html($(<span class="string">'h2'</span>).html() + <span class="string">'（'</span> + timezone +<span class="string">'）'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改打卡日记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> idata = json.data[i];</span><br><span class="line">            <span class="keyword">var</span> icheckin = $(<span class="string">'#checkin'</span>).children().eq(i);</span><br><span class="line">            <span class="keyword">var</span> number = icheckin.find(<span class="string">'span.number'</span>);</span><br><span class="line">            number.html(<span class="string">' '</span> + idata.num_checkin_days);</span><br><span class="line">            <span class="keyword">var</span> note = icheckin.find(<span class="string">'div.note'</span>);</span><br><span class="line">            <span class="keyword">if</span>(json.data[i].note_length === <span class="number">0</span>)&#123;</span><br><span class="line">                note.html(idata.info);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                note.html(idata.info + <span class="string">' , '</span> + idata.note);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> date = icheckin.find(<span class="string">'div.span4'</span>);</span><br><span class="line">            date.html(<span class="string">'&lt;strong&gt;'</span> + idata.checkin_date + </span><br><span class="line">                      <span class="string">'&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;('</span> +</span><br><span class="line">                      idata.checkin_time.replace(<span class="string">'T'</span>, <span class="string">'&amp;nbsp;&amp;nbsp;'</span>) + <span class="string">')'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>jQuery中，<code>children()</code>指直接子元素，<code>.find()</code>能递归查找子元素，<code>.eq(i)</code>为第i个元素。用jQuery来修改DOM还是十分简便的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间发现扇贝网页版显示的打卡日记和手机上看到的不一致，感觉应该是网页版开发滞后的原因。这种不一致给查卡带来了诸多不便，于是就设法解决该问题。&lt;/p&gt;
&lt;p&gt;起初我想到的方案是做一个静态页面放到对象存储上，然后对象存储开启静态服务，静态页面通过Ajax请求手机版的RESTful接口获取数据，然后生成打卡日记。不过，通过反复试验发现这种方法行不通。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$.&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;(url, function(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接使用Ajax请求会报错：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>向量微积分基础</title>
    <link href="https://jlice.top/p/7kemt/"/>
    <id>https://jlice.top/p/7kemt/</id>
    <published>2018-06-05T15:17:19.000Z</published>
    <updated>2019-03-22T12:37:10.852Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习里经常需要用到向量微积分。向量微积分其实并不难，但大学数学一般不提，导致在看机器学习的一些推导时常常感觉疑惑。</p><p>机器学习里经常用到标量和向量、向量和向量的求导，其实只是把向量对应位置的元素进行求导。但是，这些元素的组织方式有两种，分别是分子布局和分母布局，二者并无本质上的差别，只是结果相差个转置。这两种布局都存在，初学者常常混淆。</p><a id="more"></a><p>例如求<script type="math/tex">\frac {\partial \mathbf{y}} {\partial x}</script>，其中<script type="math/tex">\mathbf{y}</script>是<script type="math/tex">n</script>维列向量，<script type="math/tex">x</script>是标量。这个求导就是把<script type="math/tex">\mathbf{y}</script>里每个元素分别对<script type="math/tex">x</script>求导，但求导后是得到列向量还是行向量呢？</p><p>对于分子布局：</p><script type="math/tex; mode=display">\frac {\partial \mathbf{y}} {\partial x} = \begin{bmatrix}\frac {\partial y_1} {\partial x} \\\frac {\partial y_2} {\partial x} \\\vdots \\\frac {\partial y_n} {\partial x} \\\end{bmatrix}</script><p>对于分母布局：</p><script type="math/tex; mode=display">\frac {\partial \mathbf{y}} {\partial x} = \begin{bmatrix}\frac {\partial y_1} {\partial x} & \frac {\partial y_2} {\partial x} & \dots & \frac {\partial y_n} {\partial x} \\ \end{bmatrix}</script><p>两种布局容易混淆，建议选择自己习惯的布局即可。这里我们选择分子布局进行后面的说明。</p><p>符号约定：小写粗体：值为向量；大写粗体：值为矩阵；小写斜体：值为标量。以a、b、c、d表示和x无关的函数，u=u(x)，v=v(x)，f、g、h是函数。</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \mathbf{x}} =\begin{bmatrix}\frac{\partial y}{\partial x_1}  &\frac{\partial y}{\partial x_2}  &\dots &\frac{\partial y}{\partial x_n} \\\end{bmatrix}</script><script type="math/tex; mode=display">\frac{\partial \mathbf{y}}{\partial \mathbf{x}} =\begin{bmatrix}\frac{\partial y_1}{\partial x_1} & \frac{\partial y_1}{\partial x_2} & \cdots & \frac{\partial y_1}{\partial x_n}\\\frac{\partial y_2}{\partial x_1} & \frac{\partial y_2}{\partial x_2} & \cdots & \frac{\partial y_2}{\partial x_n}\\\vdots & \vdots & \ddots & \vdots\\\frac{\partial y_m}{\partial x_1} & \frac{\partial y_m}{\partial x_2} & \cdots & \frac{\partial y_m}{\partial x_n}\\\end{bmatrix}</script><p>这个矩阵又叫<strong>雅可比（Jacobi）矩阵</strong>。</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \mathbf{X}} =\begin{bmatrix}\frac{\partial y}{\partial x_{11}} & \frac{\partial y}{\partial x_{21}} & \cdots & \frac{\partial y}{\partial x_{p1}}\\\frac{\partial y}{\partial x_{12}} & \frac{\partial y}{\partial x_{22}} & \cdots & \frac{\partial y}{\partial x_{p2}}\\\vdots & \vdots & \ddots & \vdots\\\frac{\partial y}{\partial x_{1q}} & \frac{\partial y}{\partial x_{2q}} & \cdots & \frac{\partial y}{\partial x_{pq}}\\\end{bmatrix}</script><p>虽然看着挺复杂，但不难看出：分子布局的特点是，分子的编号排列和分子相同，分母的编号排列和分母的转置相同。</p><p>一些求导公式比较常用，在此列举一下：</p><script type="math/tex; mode=display">\frac {\partial {\mathbf{Ax}}} {\partial \mathbf{x}} = \mathbf{A}</script><script type="math/tex; mode=display">\frac {\partial \mathbf{x}^\top \mathbf{X}} {\partial \mathbf{x}} = \mathbf{A}^\top</script><script type="math/tex; mode=display">\frac {\partial \mathbf{x}^\top \mathbf{x}} {\partial \mathbf{x}} = 2 \mathbf{x}^\top</script><script type="math/tex; mode=display">\frac {\partial \mathbf{x}^\top \mathbf{A} \mathbf{x}} {\partial \mathbf{x}} = \mathbf{x}^\top(\mathbf{A} + \mathbf{A}^\top)</script><p>若$\mathbf{A}$为对称阵，则对于上式：</p><script type="math/tex; mode=display">\begin{split}\frac {\partial \mathbf{x}^\top \mathbf{A} \mathbf{x}} {\partial \mathbf{x}} &= \mathbf{x}^\top(\mathbf{A} + \mathbf{A}^\top) \\&= 2 \mathbf{x}^\top\mathbf{A}\end{split}</script><p>和、积的导数：</p><script type="math/tex; mode=display">\frac {\partial (\mathbf{u} + \mathbf{v})} {\partial \mathbf{x}} = \frac {\partial \mathbf{u}} {\partial \mathbf{x}} + \frac {\partial \mathbf{v}} {\partial \mathbf{x}}</script><script type="math/tex; mode=display">{\frac  {\partial ({\mathbf  {u}}\cdot {\mathbf  {v}})}{\partial {\mathbf  {x}}}}={\frac  {\partial {\mathbf  {u}}^{\top }{\mathbf  {v}}}{\partial {\mathbf  {x}}}}={\mathbf  {u}}^{\top }{\frac  {\partial {\mathbf  {v}}}{\partial {\mathbf  {x}}}}+{\mathbf  {v}}^{\top }{\frac  {\partial {\mathbf  {u}}}{\partial {\mathbf  {x}}}}</script><p>链式求导：</p><script type="math/tex; mode=display">\frac{\partial \mathbf{f(u)}}{\partial \mathbf{x}} =\frac{\partial \mathbf{f(u)}}{\partial \mathbf{u}} \frac{\partial \mathbf{u}}{\partial \mathbf{x}}</script><p>更多详细内容可以参考：<a href="https://en.wikipedia.org/wiki/Matrix_calculus" target="_blank" rel="noopener">Matrix calculus - Wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习里经常需要用到向量微积分。向量微积分其实并不难，但大学数学一般不提，导致在看机器学习的一些推导时常常感觉疑惑。&lt;/p&gt;
&lt;p&gt;机器学习里经常用到标量和向量、向量和向量的求导，其实只是把向量对应位置的元素进行求导。但是，这些元素的组织方式有两种，分别是分子布局和分母布局，二者并无本质上的差别，只是结果相差个转置。这两种布局都存在，初学者常常混淆。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://jlice.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
